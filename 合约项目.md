# 合约项目

## go-ethereum 单元测试

[README](./readme.md)

## mint.sol



技术要点

- ERC721：以太坊 NFT 标准，定义了铸造、转移、查询等基础接口。
- Ownable：只有合约 owner 能执行特权操作（如设置 root/提取资金）。
- Counters：安全的自增计数器，用于生成唯一 tokenId。
- MerkleProof：用 Merkle 证明验证地址是否在白名单里。（传入一个proof数组根据预先储存的root和调用者sender生成叶子节点去校验）
- 防女巫限制：限制单个地址可铸造数量，避免刷量。付费铸造：用户需支付指定 ETH 才能铸造。（白名单：链上映射维护的用户或者链下用merkleproof指定的用户才可以铸造）

```markdown 
区块链中的女巫攻击表现形式
在区块链和加密货币领域，女巫攻击可能表现为：
- 代币铸造滥用：同一用户用多个钱包地址超额参与代币铸造
- 空投收割：创建大量地址领取项目空投奖励
- 治理操纵：用虚假身份参与DAO投票影响治理结果
- P2P网络攻击：控制大量网络节点影响交易传播
防范女巫攻击
- 收取铸造费用增加攻击成本
- 身份验证系统 KYC(实名认证)
- 限制每个地址的铸造数量
- 工作量证明 solidity // 示例：要求解决简单的计算题 mapping(address => uint) public puzzles;
```


## PepeTokens.sol

这个合约是一个 ERC20 代币，叫 Pepe，主要加了“黑名单 + 交易开关 + 限购/限持 + 销毁”这些控制逻辑：

- 标准 ERC20：继承 ERC20，构造时把 \_totalSupply 全部铸给部署者。
- 黑名单：blacklist 可由 owner 拉黑/解黑地址；转账前禁止黑名单地址参与。(就是维护一个address的mapping)
- 交易开关：uniswapV2Pair（交易币对） 作为开盘判断（一个池子地址，用来判断是否开盘，为初始化就代表未开盘）未开盘只有 owner 相关地址可以转账（就是用另一个方法设置一个owner地址，判断transfer的from，to方法是否等于这个地址，是的话直接return，否则继续下面判断，下面判断不满足会revert，导致不能转账）
- 限购/限持：limited 开启且“买入”（from == uniswapV2Pair，买入是池子向其他地址转账）时，要求持仓在minHoldingAmount \~ maxHoldingAmount 范围内。
- 手动销毁：burn 允许持有人销毁自己的代币。

## floki.sol

- 核心逻辑。主合约采用erc20标准，首先固定 totalSupply() 常量，通过构造函数一次性分配给部署者。内部涉及投票机制，其他业务逻辑通过外部合约挂接。主逻辑在\_transfer转账方法

```markdown 
_transfer(from, to, amount)
- 业务：真正的“转账主流程”，包含税收与金库逻辑。
- 逻辑步骤：
  1. 基础校验（非零地址、金额 > 0、余额足够）。
  2. 调用 treasuryHandler.beforeTransferHandler（转账前钩子）。
  3. 调用 taxHandler.getTax 计算税额。
  4. 扣减 from 余额；给 to 增加税后金额。
  5. 迁移投票委托（对税后金额更新投票快照）。
  6. 若税额 > 0：把税额记到 treasuryHandler 地址余额，同时更新该地址的投票快照，并发税额转账事件。
  7. 调用 treasuryHandler.afterTransferHandler（转账后钩子）。
  8. 发出正常转账事件（税后金额）。

```


### 治理逻辑

- 投票权随余额变动，委托给代表人；转账时同步迁移投票权，确保权重与真实持币一致。

```markdown 
1. 投票权 = 余额
     你拥有多少代币，理论上就拥有多少投票权。
2. 投票权可以委托
   把自己的投票权“挂在”某个代表人名下。（本质上一个映射，通过delegates的映射去保存address=>deletegat address）。投票权只通过delegate address作为key的一个映射去纪录快照，本人不保存任何投票信息。
3. 投票权变化会被记录成“快照”
     每当某个代表的投票权变化时，合约会记录一个“区块高度 + 投票数”的快照。
     这就让你可以在未来查询“某地址在历史某个区块的投票权”。防止投票期间通过临时转账来影响结果，保证公平性。
  修改时：
  checkpoints[delegate][index] = { blockNumber, votes }
  numCheckpoints[代表人] = index
  numCheckpoints保存递增的这个序号，checkpoints通过代理人和这个序号定位快照内容，每一次变更都递增一个index，一个区块上的多笔交易对应一个index去更新。
  查询时：
  查找某个区块时，用二分查找，index是递增的，查询某个区块号，然后如果小就加index，然后继续查继续对比blocknumber，这样查询效率比较高。

```


- 税收设计：转账税额通过第三方合约独立计算并将税额划入金库地址，金库也纳入投票体系，形成资金与治理的闭环。
- EIP-712 签名委托：支持无 gas 委托，提高治理参与度支持签名委托，不需要持币者自己付 gas 发交易。
- 扩展性和钩子机制：税收与金库策略通过外部合约挂接，无需改动即可调整业务规则。给业务策略（黑名单、限额、自动分配等）留出空间。（方式：税收与逻辑抽象成 ITaxHandler / ITreasuryHandler 接口，合约地址可由 owner 替换。金库逻辑使用before/after 的钩子逻辑处理）

## MetaNodeStake.sol

背景：去中心化交易所为了增加流动性，用户存入代币对后可以获取lp token，为了鼓励用户存入代币对，提供lp token的质押合约收益，质押token就可以获取收益。

### 功能层面：

- 支持多种资产质押：ETH 和任意 ERC20 都可以开池。
- 自动发放区块奖励：用户质押后按时间与比例持续获得 MetaNode 奖励。
- 质押与收益解耦：随时领取奖励，不影响本金。
- 解质押需等待：提取本金要先申请、等待锁定区块。
- 管理可配置：管理员可调奖励速率、池权重、最小质押额与锁定期。

### 用户操作（普通参与者）：

- depositETH / deposit：质押 ETH 或 ERC20。
- unstake：发起解质押请求（进入锁定期）。
- withdraw：判断是否解锁，然后提取已解锁的本金，如果有收益，需要另外调用claim接口领取收益。
- claim：领取奖励代币。

  管理员操作（ADMIN\_ROLE）：
- setMetaNode：设置奖励代币地址。
- addPool：新增资金池（代币地址、权重、最小质押、锁定区块）。
- updatePoolInfo：更新池子的最小质押/锁定区块。
- setPoolWeight：调整池权重（影响奖励分配比例）。
- setStartBlock / setEndBlock：调整奖励时间窗口。
- setMetaNodePerBlock：调整每区块奖励数量。
- 允许升级合约实现（UUPS 模式）。

### 合约实现重点

- 多池质押：支持 ETH + ERC20 多池，按 poolWeight 分配区块奖励。
- 奖励累计模型：用 accMetaNodePerST + finishedMetaNode 做快照，确保奖励精确结算、避免重复领取。

```markdown 
计算用户当前应得奖励：
  pending = user.stAmount * accMetaNodePerST - user.finishedMetaNode
  - 把 pending 加到 user.pendingMetaNode（只是记账，不转账）。
  - 最后更新 user.finishedMetaNode = user.stAmount * accMetaNodePerST
  解释：本质上相等于纪录了这个节点的accMetaNodePerST（相当于纪录这个池子这个新增的收益，是一个累加的），等到下个有人操作的节点变化时，需要纪录一下这个人的当时那个ccMetaNodePerST累计到了多少，（其他人的不用记，因为其他人的这段时间内不管accMetaNodePerST如何变化，一直累计就行了accMetaNodePerST会一直变大一直累计，我最后把累计的最终值乘以我一直不变的amount就行了），然后从新开始积累。我需要纪录一下这个人此时的积累的值那个节点，为了方便以后从这个开始从新累积，从新开始累积时，这个人又是一个新的新amount了，下一次计算时也还是这个amout，所以干脆直接纪录新amount和此时这个节点accMetaNodePerST的乘积值，那下一次找到那个累计值，乘以不变的amout，再减掉上次纪录的，直接就是这段区间内获得的收益了。
  accMetaNodePerST是一次一次的累加，每一次开始和结束amount都是一样的，如果amout变化了，就一个新的开始累加。
```


- 解质押延迟：unstake 立即减少份额并记请求，withdraw 仅在解锁后提取本金，claim提取收益。
- 权限与安全：ADMIN\_ROLE/UPGRADE\_ROLE 管理参数、暂停功能，可升级（UUPS），关键操作可暂停。

### UniswapV2Pair.sol

#### 关键变量的含义

- balance0/balance1：合约里当前真实余额（IERC20.balanceOf 读出来的）。
- reserve0/reserve1：上次 \_update 记录的储备快照（用于定价和计算）。
- 可以用balance和reserve和差值计算输入输出
- totalSupply：LP 代币总量（代表池子总份额）。
- liquidity：本次 mint/burn 的 LP 变动量
- balanceOf：对于mint时通过输入计算开平方，保存liquidity在balanceOf的映射
- price0CumulativeLast price1CumulativeLast blockTimestampLast：价格累计值（TWAP）。（计算预言机Oracle）

#### mint（添加流动性）里变量怎么变

计算出reserve0和balance0（reserve1和balance1）的差额，按照相对reserve增加的比例对应增加totalSupply相同的比例，就是liquidity。（两个代币增加比例不相等时，就取增加的比例最小值）初始增加是相乘然后开平方

#### burn（移除流动性）里变量怎么变

burn时取出balanceOf映射中的liquidity，然后按照liquidity/totalSupply比例计算出应该burn的balance0和 balance1的部分，transfer给to的address

#### swap（交易）里变量怎么变

swap时先将要转出的代币（方法参数中）转账给to地址，根据转账后balance和旧的reserve计算出转入的代币，根据转入的值按照3%的手续费计算新的reserve，因为实际上新的reserve是要扣除掉手续费的，新的reserve的乘积要大于等于旧的reserve的乘积保证新k值始终大于等于旧的k值。（swap 用含手续费的 x\*y>=k 校验控制价格曲线。）协议费如何计算kLast：上次流动性事件后记录的 reserve0*reserve1（用于协议费）（每次mint和burn时都会计算新的reserve0*reserve1（就是当前的balance0和balance1），然后计算这个k的变化，取这个差值的1/6作为协议费）

#### 预言机如何计算（计算TWAP）

每次 \_update（swap/mint/burn/sync）时，就把“当前价格 × 上一次与这次的时间差”累加进去。

价格用 reserve1 / reserve0 和 reserve0 / reserve1 表示（旧的reserve而不是新读出来的balance），计算出来累加到price0CumulativeLast/price1CumulativeLast，同时保存blockTimestampLast。（上一次与这次的时间差的本质就是用时间差加权）

```markdown 
下面是这条校验公式的推导（用同样的变量名）：
1. 交换后真实余额
设旧储备为 x = _reserve0，y = _reserve1。
交换后余额是：
- balance0 = x - amount0Out + amount0In
- balance1 = y - amount1Out + amount1In
1. 手续费作用在“输入”上
手续费 0.3% ⇒ 有效输入 = amountIn * 997/1000。
所以“用于满足恒定乘积的有效余额”应当是：
- x' = x - amount0Out + amount0In * 997/1000
- y' = y - amount1Out + amount1In * 997/1000
恒定乘积约束是：
    x' * y' >= x * y
1. 去掉小数
把上式两边乘以 1000^2：
  ( (x - amount0Out) * 1000 + amount0In * 997 )
  *
  ( (y - amount1Out) * 1000 + amount1In * 997 )
  > = x * y * 1000^2
  注意：
- (x - amount0Out) * 1000 + amount0In * 997
等价于
- balance0 * 1000 - amount0In * 3
因为 balance0 = x - amount0Out + amount0In，
所以 balance0*1000 - amount0In*3 = (x - amount0Out)*1000 + amount0In*997
  同理对 balance1 也成立
```


#### **整体关系（核心控制点）**

- balance 是真实世界，reserve 是系统记账；差值就是“本次变化量”。
- totalSupply/liquidity 控制份额，保证增减流动性公平。
- \_update 把真实余额写回储备，并维护 TWAP。
- 保证扣除掉手续费的xy大于等于k

### uniswap2问题

#### 简要总结

- Uniswap 是去中心化的自动做市协议，用不可升级合约实现。
- 每个交易对合约管理两种 ERC20 的流动性池。
- LP 按等值存入两种币，获得 LP 代币，代表池子份额。
- 交易遵循恒定乘积 x\*y=k，因此大额交易会越来越不划算。
- 0.3% 交易费留在池子里，增加 k，最终变成 LP 收益（相当于在计算xy=k这个乘积时排除掉手续费）。

#### xy=k的作用原理

在任意价格下，只要池子里还有两种资产，就一定能成交。x\*y=k 的作用是：

- 只要 x 和 y 都大于 0，曲线就存在。
- 你想买走 y，必须按曲线把 x 增加到新的位置。
- 这个过程中始终保持xy>=k，价格会变差（就是这个斜率会变化），但不会“没法成交”。

#### 简单回答问题

a：什么是 AMM，与订单簿有什么区别

- AMM（自动做市商）用一条数学曲线自动报价，不依赖挂单。任何时刻都能成交，但价格随交易

  量滑动。订单簿依赖买卖挂单，价格来自撮合，流动性取决于挂单深度。
- AMM 的优势是“始终有报价”；劣势是大额交易滑点明显、容易被套利修正。

b：AMM 的核心算法

- 以 Uniswap V2 为例是恒定乘积：x \* y = k。
- x 和 y 是两种代币的储备，交易必须让乘积不降低（含手续费）。

c：什么是滑点，怎么避免过高（含三明治攻击）

- 滑点：期望价格与实际成交价格的差距，来源于交易量占池子比例太大或价格被抢跑。
- 避免方法：
  1. 拆分大单，减少单次冲击。
  2. 选择流动性更深的池子（更大 TVL）。
  3. 设置合理的 slippage tolerance 和 minAmountOut。
  4. 使用聚合器（多路拆单）。
  5. 防三明治：使用私有 RPC/MEV 保护（如 Flashbots/MEV-Blocker），或降低滑点容忍度，
  避免被夹。

d:什么是无常损失?

- 在 Uniswap V2 中，“无常损失”（Impermanent Loss）指的是：你作为 LP 提供双边资产到池子里，价格发生变化后，池子通过恒定乘积做市自动再平衡，使你持有的两种资产数量发变化。结果是：如果你当初只是把两种资产拿在手里不动（HODL），通常会比做LP 更值钱，这个差额就是无常损失。

d：LP 的作用是什么

- LP 提供两种代币的资金，让池子有流动性可以交易。
- LP （liquid provider）获得 LP 代币，代表池子份额。
- 交易手续费会留在池子里，增加储备，LP 通过赎回时获得收益。
- 风险：无常损失（价格变化导致 LP 持仓价值低于单独持有）。

e: 三明治攻击是什么

在 Uniswap V2 中，“三明治攻击”（Sandwich Attack）是一种 MEV 策略：攻击者在同一区块内对受害者交易前后各插一笔交易，从而夹击获利。典型流程是：

- 攻击者先在前面买入，推高价格。
- 受害者交易按更高价格成交。
- 攻击者随后卖出，回落价格并赚取差价。

  三明治成立的原因是：
  - 价格由池子储备决定，交易会沿着 x\*y=k 曲线滑点成交。
  - 攻击者只要在区块排序上把自己的交易放在受害者前后，就能让受害者在更差的价格成交，再把价格拉。

### uniswap3问题

#### uniswap3 core合约

核心合约 UniswapV3Pool 。

#### 部署交易池初始化交易池

确认对应的交易池合约尚未被创建，调用 deploy，参数为工厂合约地址，token0 地址，token1 地址，fee，以及 tickSpacing。记录价格和预言机的状态

```javascript 
//通过 fee 获取对应的 tickSpacing。
int24 tickSpacing = feeAmountTickSpacing[fee];
pool = deploy(address(this), token0, token1, fee, tickSpacing);
```


#### 创建流动性

```markdown 
address token0; // token0 地址
address token1; // token1 地址
uint24 fee; // 费率    ------这三个参数可以确定是哪个池子
int24 tickLower; // 流动性区间下界
int24 tickUpper; // 流动性区间上界
uint256 amount0Desired; // 添加流动性中 token0 数量
uint256 amount1Desired; // 添加流动性中 token1 数量
uint256 amount0Min; // 最小添加 token0 数量 -------这里是前端通过滑点计算出来的
uint256 amount1Min; // 最小添加 token1 数量   -------避免价格在提交时发生太大变化
address recipient; // 头寸接受者的地址
uint256 deadline; // 过期的区块号
```


计算出需要的 liquidity 和对应的amount0/amount1（这个amount与前端传入的amount不一致，是根据前端传入的amout计算出liquidity后再调整这个amount，得到最终的amount0/amount1），然后把头寸铸造成 NFT 给 recipient，并把头寸信息（区间、流动性、费率等）写入\_positions。

#### 添加流动性



```javascript 
uint256 tokenId; // 头寸 id  根据头寸id取出pool信息
uint256 amount0Desired; // 添加流动性中 token0 数量
uint256 amount1Desired; // 添加流动性中 token1 数量
uint256 amount0Min; // 最小添加 token0 数量  -------这里是前端通过滑点计算出来的
uint256 amount1Min; // 最小添加 token1 数量    -------避免价格在提交时发生太大变化
uint256 deadline; // 过期的区块号
```


#### 减少流动性(记录一下代币的数量，用collect去领取)

```javascript 
uint256 tokenId; // 头寸 id
uint128 liquidity; // 减少流动性数量
uint256 amount0Min; // 最小减少 token0 数量 ------实际可取出的 token0 或 token1 
uint256 amount1Min; // 最小减少 token1 数量   ------少于你设定的下限，交易会回滚
uint256 deadline; // 过期的区块号
```


#### Collect

```markdown 
uint256 tokenId; // 头寸 id
address recipient; // 接收者地址
uint128 amount0Max; // 最大 token0 数量
uint128 amount1Max; // 最大 token1 数量
amount0Max 和 amount1Max 是你这次“最多取出”的上限。如果应领取的费用或者代币超过你设置的上限，本次只会取到上限，剩余的仍留在头寸里。通常想一次性全取，就把它们设成type(uint128).max。
```


#### swap

UniswapV3的path支持多跳swap。path 会按 tokenIn + fee + tokenOut + fee + tokenOut...编码，表示你可以从A换到B，再从B换到C。每一跳就是一个池子，所以会涉及多个交易池。单池swap也可以，path只包含一跳即可。多跳时每一跳的tokenOut就是下一跳的tokenIn。

```javascript 
bytes path; // swap 路径，可以解析成一个或多个交易池
address recipient; // 接收者地址
uint256 deadline; // 过期的区块号
uint256 amountIn; // 输入代币数量
uint256 amountOutMinimum; // 最少输出代币数量 --防止获得的代币太少，太少就revert
```


### Uniswap3核心逻辑

根据公式l在V3 在区间内用的是“恒定流动性曲线”：

- `(x + L/Pb) * (y + L*Pa) = L^2 `也就是lp区间固定pa pb固定，l就固定了。
- 对于给定价格区间 \[pa,pb]\[p\_a,p\_b]\[pa,pb]，Uniswap V3 通过引入虚拟储备(函数公式`(x + L/Pb) * (y + L*Pa) = L^2 `相当于将xy=k的函数平移到x，y坐标轴相交)，使得区间内的 swap 行为在代数上等价于一个完整的` xy=k` AMM；因此在该区间内，价格函数与 V2 完全一致，但由于不需要为区间外价格准备真实储备，LP 实际需要提供的 x,y显著减少。
- 创建流动性时，会给出一个价格pc，给出一个lp区间pa，pb，在这个价格（两个token的比例和数量）计算出一个初始的流动性L，在lp区间内，这个流动性都是一样的，变化的只是这个token的比例，tick上去纪录这个lp的变化。
- 创建头寸时，只在 tickLower 记 +L，在 tickUpper 记 -L。如果当前价格所在的 tick 满：tickLower <= currentTick < tickUpper，这笔 L 立刻算进活跃流动性。
- V3 用 tick bitmap 存“已初始化的 tick”，每次 swap 只会：从当前 tick 开始，找到下一个已初始化 tick计算价格到那个 tick 需要的成交量价格跨过该 tick 时，把该 tick 的 liquidityNet 加到活跃流动性。
- 每次添加流动性时，都有从某个固定的价格，也就是当前的价格，去添加token的数量，然后，在端点纪录流动性。（不是上行就是下行）价格从 S 走到 S' 需要的 token0：amount0 = L \* (S' - S) / (S' \* S)。同时卖出的 token1：amount1 = L \* (S' - S)。

#### a：集中流动性的优势是什么，怎么实现的

V3的核心是通过盘口区间（也就是LP区间）提供流动性（集中式流动性），解决v2时资金利用率的问题。

```markdown 
对于给定价格区间 [pa,pb][p_a,p_b]，Uniswap V3 通过引入虚拟储备使得区间内的 swap 行为在代数上等价于一个完整的 xy=k AMM；
相当于将xy=k的函数平移到x，y坐标轴相交，(x + L/Pb) * (y + L*Pa) = L^2，因此在该区间内，价格函数与 V2 完全一致，但由于不需要为区间外价格准备真实储备，LP 实际需要提供的 x,y显著减少。
```


#### b：tick跟价格有什么关系，为什么需要tick

Tick = 价格轴上的一个离散刻度点，

Tick 是 Uniswap V3 用来把连续价格轴离散化的结构，

Tick 上存的是“流动性变化量”，而不是流动性本身，

它与价格变化快慢的关系是，在一个 tick 区间内，价格从 p\_start到p\_end的变化，所需的 token0 成交量正比于（相当于L流动性越大，在一个价格区间内成交量越大，或者固定成交量和L越大，价格变化范围越小）

tick使得“区间流动性”可以通过在边界点记录流动性变化量来高效实现；在任意两个 tick 之间，活跃流动性保持不变，只有当价格跨越 tick 时，才会触发流动性的加入或移除。

#### c：tickspacing跟费率有什么关系，为什么

LP 的上下边界 tick 必须是 tickSpacing 的整数倍，LP 区间 = 某一个 LP 选择的“我在哪些价格上提供流动性”，tickSpacing = LP 区间边界允许的最小步长。

```markdown 
tickspacing的设置目的是防止：
LP 区间越细
LP 数量越多
tick 上的 ΔL 越碎
合约的存储和计算成本会爆炸 
tickSpacing 越大：可用 tick 更稀疏，价格格子更“粗”
每个 tick 流动性越多：因为 LP 只能在更少的 tick 上布点，流动性会集中到这些更粗的价格格子里
tick 之间滑点越大：价格从一个 tick 跳到下一个 tick 的“离散步长”更大，单次跨越的价格变动更
明显

```


因为LP区间和计算费率有关，低费率池必须允许小 tickSpacing，因为价格波动比较小，相应的lp区间也小一点，保证对应的手续费。
如果在 1% 费率池里（高费率）：LP 把区间切得极细，价格稍微来回震荡一下，LP 会以极小的风险，反复收取高额手续费，就是为了制约这种现象。

